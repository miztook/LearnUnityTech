https://segmentfault.com/a/1190000038943912

LZMA和LZ4
LZMA是流压缩方式（stream-based）。流压缩再处理整个数据块时使用同一个字典，它提供了最大可能的压缩率，但是只支持顺序读取。
所以加载AB包时，需要将整个包解压，会造成卡顿和额外内存占用。

LZ4是块压缩方式（chunk-based）。块压缩的数据被分为大小相同的块，并被分别压缩。如果需要实时解压随机读取，块压缩是比较好的选择。
LoadFromFile()和LoadFromStream()都只会加载AB包的Header，相对LoadFromMemory()来说大大节省了内存。

对于GameObject来说，通常情况下需要对其进行改动，所以它是完全复制一份该资源来进行的实例化。
也就是说，当AB包中的GameObject从内存中卸载后，实例化的GameObject不会因此丢失。
并且对实例化对象的修改不会影响到GameObject资源。

对于Shader和Texture来说，通常情况下不需要对其进行改动，所以它是通过引用来进行的实例化。
也就是说，当AB包中的Shader和Texture资源从内存中卸载后，实例化的Shader和Texture会出现资源丢失的情况。
并且对实例化对象的修改会影响到Shader和Texture资源。

对于Material和Mesh来说，有时候可能需要对其进行改动，所以它是通过引用+复制来进行的实例化。
也就是说，当AB包中的Material和Mesh资源从内存中卸载后，实例化的Material和Mesh会出现资源丢失的情况。
并且对实例化对象的修改不会影响到Material和Mesh资源。